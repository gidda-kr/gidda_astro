---
// src/pages/wiki/[slug].astro

import WikiPageLayout from '~/layouts/wiki_page.astro';
import Content from '~/components/Content.astro';
import ListItem from '~/components/ListItem.astro';
import LinkCard from '~/components/LinkCard.astro';
import Footnotes from '~/components/Footnotes.astro';
import Callout from '~/components/Callout.astro';
import Image from '~/components/Image.astro';

import MarkdownIt from 'markdown-it';

const components = {
  'common.content': Content,
  'common.list-item': ListItem,
  'common.link-card': LinkCard,
  'common.footnotes': Footnotes,
  'common.callout': Callout,
  'common.image': Image,
};

export async function getStaticPaths() {
  const strapiUrl = 'https://strapi-app-63132904920.asia-northeast3.run.app';
  const apiPath = '/api/wikis?populate[content][populate]=*';

  try {
    const response = await fetch(`${strapiUrl}${apiPath}`);
    if (!response.ok) {
      console.error(`Strapi API 호출 실패: ${response.status}`);
      return [];
    }
    const { data } = await response.json();
    if (!data) return [];

    const allSlugs = new Set(data.map(wiki => wiki.slug).filter(Boolean));

    return data.map((wiki) => {
      if (!wiki || !wiki.slug) return null;
      return {
        params: { slug: wiki.slug },
        props: {
          wiki: wiki,
          allWikiSlugs: Array.from(allSlugs)  // ✅ 이 이름 확인
        },
      };
    }).filter(Boolean);

  } catch (error) {
    console.error("getStaticPaths 함수 실행 중 예외 발생:", error);
    return [];
  }
}

// ✅ 핵심 수정: 정확한 prop 이름 사용
const { wiki, allWikiSlugs } = Astro.props;
const allSlugsSet = new Set(allWikiSlugs);

// ✅ 디버깅용 로그 추가
console.log('allWikiSlugs:', allWikiSlugs);
console.log('allSlugsSet size:', allSlugsSet.size);

if (!wiki) {
  return Astro.redirect('/404');
}

// --- ✅ meta description 생성 로직 시작 ---
const firstContentItem = wiki.content?.find(
    (item) => item.__component === 'common.content'
);

let pageDescription = '';

if (firstContentItem && firstContentItem.content) {
  let plainText = firstContentItem.content
      .replace(/<[^>]*>/g, '')
      .replace(/\[\^[^\]]+\]/g, '')
      .replace(/\[[^\]]+\]\([^)]+\)/g, '');

  pageDescription = plainText.length > 150
      ? `${plainText.substring(0, 150).trim()}...`
      : plainText.trim();
}
// --- ✅ meta description 생성 로직 끝 ---

// --- ✅ Open Graph 이미지 로직 시작 ---
let ogImage = '/default-og-image.png'; // 기본 폴백 이미지 (필요에 따라 경로 변경)

// wiki.content에서 common.image 컴포넌트를 찾습니다.
const firstImageComponent = wiki.content?.find(
    (item) => item.__component === 'common.image' && item.image && item.image.url
);

if (firstImageComponent) {
  // 찾은 이미지 컴포넌트의 URL을 사용합니다.
  ogImage = firstImageComponent.image.url;
}
// --- ✅ Open Graph 이미지 로직 끝 ---

const globalFootnotes = new Map<string, { number: number; content: string; refs: string[] }>();
let footnoteCounter = 1;
const footnoteRefCounters = new Map<string, number>();

const mdForContent = new MarkdownIt({
  html: true,
  typographer: true,
  linkify: true,
});

const defaultRender = mdForContent.renderer.rules.link_open || function(tokens, idx, options, env, self) {
  return self.renderToken(tokens, idx, options);
};

mdForContent.renderer.rules.link_open = function (tokens: MarkdownIt.Token[], idx: number, options: MarkdownIt.Options, env: unknown, self: MarkdownIt.Renderer) {
  const token = tokens[idx];
  const hrefIndex = token.attrIndex('href');

  if (hrefIndex >= 0) {
    const href = token.attrs![hrefIndex][1];

    if (href.startsWith('/wiki/')) {
      const linkSlug = href.substring('/wiki/'.length);

      // ✅ 디버깅용 로그 추가
      console.log('Checking link slug:', linkSlug, 'exists:', allSlugsSet.has(linkSlug));

      if (allSlugsSet && !allSlugsSet.has(linkSlug)) {
        token.attrJoin('class', 'red-link');
      }
    }
  }
  return defaultRender(tokens, idx, options, env, self);
};

// --- 1단계: 각주 정의 수집 ---
function collectFootnoteDefinitions(contentArray) {
  if (!contentArray || !Array.isArray(contentArray)) return;

  contentArray.forEach(item => {
    if (item.__component === 'common.content' && item.content) {
      item.content.replace(/^\[(\^[^\]]+)\]:\s*(.+)$/gm, (match, ref, definition) => {
        if (!globalFootnotes.has(ref)) {
          globalFootnotes.set(ref, {
            number: footnoteCounter++,
            content: definition.trim(),
            refs: []
          });
        }
        return match;
      });
    }
    else if (item.__component === 'common.list-item' && item.items) {
      item.items.forEach(listItem => {
        if (listItem && typeof listItem.ListText === 'string') {
          listItem.ListText.replace(/^\[(\^[^\]]+)\]:\s*(.+)$/gm, (match, ref, definition) => {
            if (!globalFootnotes.has(ref)) {
              globalFootnotes.set(ref, {
                number: footnoteCounter++,
                content: definition.trim(),
                refs: []
              });
            }
            return match;
          });
        }
      });
    }
  });
}

// --- 2단계: 각주 참조 변환 및 콘텐츠 렌더링 ---
function processContentAfterFootnotesCollected(contentArray) {
  if (!contentArray || !Array.isArray(contentArray)) return [];

  const processFootnoteRefsInText = (text: string) => {
    return text.replace(/\[(\^[^\]]+)\]/g, (match, ref) => {
      const footnote = globalFootnotes.get(ref);
      if (footnote) {
        const currentCount = (footnoteRefCounters.get(ref) || 0) + 1;
        footnoteRefCounters.set(ref, currentCount);

        const displayRefText = currentCount === 1 ? `${footnote.number}` : `${footnote.number}:${currentCount}`;
        const internalRefId = `${footnote.number}:${currentCount}`;

        footnote.refs.push(internalRefId);

        return `<sup><a href="#fn${footnote.number}" id="fnref${internalRefId}" class="footnote-ref">${displayRefText}</a></sup> `;
      }
      return match;
    });
  };

  return contentArray.map(item => {
    if (item.__component === 'common.content' && item.content) {
      let currentContent = item.content;

      currentContent = currentContent.replace(/^\[(\^[^\]]+)\]:\s*(.+)$/gm, '');
      currentContent = processFootnoteRefsInText(currentContent);

      const htmlContent = mdForContent.render(currentContent);
      return { ...item, content: htmlContent };

    } else if (item.__component === 'common.list-item' && item.items) {
      const processedItems = item.items.map((listItem, index) => {
        if (listItem && typeof listItem.ListText === 'string') {
          let listItemText = listItem.ListText;
          listItemText = listItemText.replace(/^\[(\^[^\]]+)\]:\s*(.+)$/gm, '');
          listItemText = processFootnoteRefsInText(listItemText);

          const htmlListItemText = mdForContent.render(listItemText);
          const finalHtml = htmlListItemText.replace(/^<p>(.*)<\/p>\s*$/s, '$1').trim();

          return {
            ...listItem,
            ListText: finalHtml
          };
        }
        return listItem;
      });
      return { ...item, items: processedItems };
    }

    else if (item.__component === 'common.callout' && item.content) {
      // Callout의 content와 source를 마크다운으로 렌더링합니다.
      const processedContent = mdForContent.render(processFootnoteRefsInText(item.content));
      let processedSource = item.source || '';

      if (item.source) {
        // source도 마크다운 렌더링을 적용합니다.
        const renderedSource = mdForContent.render(item.source);
        // render() 함수가 자동으로 생성하는 <p> 태그를 제거하여 깔끔하게 표시합니다.
        processedSource = renderedSource.replace(/^<p>(.*)<\/p>\s*$/s, '$1').trim();
      }

      return { ...item, content: processedContent, source: processedSource };
    }
    // ✅ 여기에 common.image 처리 로직 추가
    else if (item.__component === 'common.image') {
      let processedCaption = item.caption || '';
      let processedCopyright = item.copyright || '';

      // caption 필드가 있다면 마크다운 렌더링 (각주 처리 제외)
      if (item.caption) {
        const renderedCaption = mdForContent.render(item.caption);
        // 마크다운 렌더러가 자동으로 생성하는 <p> 태그를 제거하여 깔끔하게 표시
        processedCaption = renderedCaption.replace(/^<p>(.*)<\/p>\s*$/s, '$1').trim();
      }

      // copyright 필드가 있다면 마크다운 렌더링 (각주 처리 제외)
      if (item.copyright) {
        const renderedCopyright = mdForContent.render(item.copyright);
        // 마크다운 렌더러가 자동으로 생성하는 <p> 태그를 제거하여 깔끔하게 표시
        processedCopyright = renderedCopyright.replace(/^<p>(.*)<\/p>\s*$/s, '$1').trim();
      }

      return {
        ...item,
        // Image.astro 컴포넌트가 받는 prop 이름에 맞춰서 전달
        displayCaption: processedCaption,
        copyright: processedCopyright,
      };
    }

    return item;
  });
}

// --- 실행 순서 ---
collectFootnoteDefinitions(wiki.content);

const processedContent = processContentAfterFootnotesCollected(wiki.content);

if (globalFootnotes.size > 0) {
  const hasFootnotesComponent = processedContent.some(item => item.__component === 'common.footnotes');

  if (!hasFootnotesComponent) {
    processedContent.push({
      __component: 'common.footnotes',
      id: 'auto-generated-footnotes'
    });
  }
}

const lastUpdated = new Date(wiki.updatedAt).toLocaleDateString('ko-KR', {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
});
---

<WikiPageLayout title={wiki.title} description={pageDescription}>
  <article class="wiki-content">
    <h1>{wiki.title}</h1>
    <div class="wiki-meta">
      <span class="page-type-label">위키</span>
      <p class="last-updated">최근 업데이트: {lastUpdated}</p>
    </div>

    {processedContent.map((componentData, index) => {
      const Component = components[componentData.__component];
      if (!Component) {
        console.warn(`컴포넌트를 찾을 수 없습니다: ${componentData.__component}`);
        return null;
      }

      if (componentData.__component === 'common.footnotes') {
        return <Component key={`${componentData.__component}-${index}`} footnotesMap={globalFootnotes} />;
      }
      return <Component key={`${componentData.__component}-${index}`} {...componentData} />;
    })}
  </article>
</WikiPageLayout>

<style is:global>
  .wiki-content a.red-link {
    color: #ff6666;
    text-decoration: none;
  }
  .wiki-content a.red-link:hover {
    color: #ff3333;
    text-decoration: underline;
  }

  .footnote-ref {
    vertical-align: super;
    font-size: 0.75em;
    line-height: 1;
    text-decoration: none;
    color: #388E3C;
    font-weight: bold;
  }
  .footnote-ref:hover {
    text-decoration: underline;
  }

  .wiki-meta {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-top: -0.5rem;
    margin-bottom: 1.5rem;
  }

  .page-type-label {
    display: inline-block;
    background: #355E3B;
    color: white;
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 0.5rem 1rem;
    border-radius: 5px;
    vertical-align: middle;
    line-height: 1;
    margin: 0;
  }
</style>

<style>
  .last-updated {
    color: #666;
    font-size: 0.9em;
    margin: 0;
  }
</style>